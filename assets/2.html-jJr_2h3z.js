import{_ as i,c as e,a,o as p}from"./app-Dh5bFHR3.js";const t="/blog/assets/image-20220315215803058-D3AaNy7J.png",s="/blog/assets/image-20220316085102186-jEotqPMs.png",n="/blog/assets/image-20220316091702363-CNwbV8lA.png",u={};function r(c,l){return p(),e("div",null,l[0]||(l[0]=[a('<ul><li>单处理器系统</li><li>多处理器系统 <ul><li>优点：增加<strong>吞吐量</strong>，规模<strong>经济</strong>，增加<strong>可靠</strong>性</li><li>类型：非对称处理和对称处理两种 <ul><li>非对称处理：主从结构一个主处理器控制系统，其他处理器向主处理器要任务或者做预先规定的任务</li><li>对称处理（SMP）每个处理器都参与完成操作系统的所有任务</li><li>处理两种</li></ul></li></ul></li><li>集群系统 <ul><li>将多个CPU组合在一起，由两个或多个独立系统组成，每个节点可为单处理器系统或多个系统</li><li>具有高可用性</li><li>对称集群和非对称集群</li></ul></li></ul><h2 id="操作系统服务" tabindex="-1"><a class="header-anchor" href="#操作系统服务"><span>操作系统服务</span></a></h2><p><img src="'+t+'" alt="image-20220315215803058"></p><h2 id="操作系统运行模式" tabindex="-1"><a class="header-anchor" href="#操作系统运行模式"><span>操作系统运行模式</span></a></h2><h3 id="区分应用程序和操作系统程序" tabindex="-1"><a class="header-anchor" href="#区分应用程序和操作系统程序"><span>区分应用程序和操作系统程序</span></a></h3><p><img src="'+s+'" alt="image-20220316085102186"></p><p>双重模式提供保护手段，防止操作系统和用户程序受到错误用户程序的影响。</p><ul><li><p>硬件从内核开始，系统加载</p></li><li><p>用户模式：执行用户程序</p></li><li><p>遇到陷阱和中断 ：用户模式切换到内核模式</p></li><li><p>两种运行模式</p><ul><li>用户模式</li><li>内核模式（特权模式）</li></ul></li><li><p>记录处理器状态标志</p><ul><li><p>程序状态字PSW</p><ul><li><p>CPU的工作状态码</p><ul><li>指明管态还是目态，用来说明当前在CPU上执行的是操作系统还是一般用户，从而决定其是否可以使用特权指令或拥有其他的特殊权力</li></ul></li><li><p>条件码</p><ul><li>反映指令执行后的结果特征</li></ul></li><li><p>中断屏蔽码</p><ul><li>指出是否允许中断</li></ul></li></ul></li><li><p>控制指令执行顺序并保留和指示与程序有关的系统状态，主要作用是实现程序状态的保护和恢复。</p></li><li><p>每个程序都有一个与其执行相关的PSW，每个处理器都设置一个PSW寄存器。程序占有处理器执行，它的PSW将占有PSW寄存器。</p></li></ul></li><li><p>实现方式</p><ul><li>硬件增加模式位， <ul><li>0：内核模式</li><li>1：用户模式</li></ul></li></ul></li></ul><p><img src="'+n+'" alt="image-20220316091702363"></p><ul><li>处理器状态标志 <ul><li>管理状态（特权状态、系统模式、特态或管态）</li><li>用户状态（目标状态、用户模式、常态或目态)</li></ul></li></ul><h2 id="系统调用" tabindex="-1"><a class="header-anchor" href="#系统调用"><span>系统调用</span></a></h2><h3 id="系统调用的类型" tabindex="-1"><a class="header-anchor" href="#系统调用的类型"><span>系统调用的类型</span></a></h3><ul><li><p>进程控制 。</p><ul><li><p>结束、中止 。</p></li><li><p>加载、执行 。</p></li><li><p>创建进程、 终止进程 。</p></li><li><p>获取进程属性、 设置进程属性 。</p></li><li><p>等待时间。</p></li><li><p>等待事件、信号事件 。</p></li><li><p>分配和释放内存</p></li></ul></li><li><p>文件管理</p><ul><li>创建文件、 删除文件 。</li><li>打开、 关闭 。读、 写、 重新定位 。</li><li>获取文件属性、 设置文件属性</li></ul></li><li><p>设备管理</p><ul><li>请求设备、 释放设备 。</li><li>读、 写、 重新定位 。</li><li>获取设备属性、 设置设备属性 。</li><li>逻辑附加或分离设备</li></ul></li><li><p>信息维护</p><ul><li>获取时间或日期、设置时间或日期 。</li><li>获取系统数据、设置系统数据 。</li><li>获取进程、 文件或设备属性 。</li><li>设置进程、 文件或设备属性</li></ul></li><li><p>通信</p><ul><li>创建、删除通信连接 。</li><li>发送、 接收消息 。传送状态信息</li><li>附加或分离远程设备</li></ul></li></ul><h3 id="与函数调用的区别" tabindex="-1"><a class="header-anchor" href="#与函数调用的区别"><span>与函数调用的区别</span></a></h3><ul><li>调用形式和实现方式不同 <ul><li>函数调用转向的地址固定，而系统调用按功能号进行；</li><li>函数调用在用户态执行，只能访问用户栈，系统调用在核心态执行，访问核心栈。</li></ul></li><li>被调用代码的位置不同 <ul><li>函数调用是静态的，调用程序和被调用代码处于同一程序内；</li><li>系统调用是动态的，系统调用的代码位于操作系统中。</li></ul></li><li>提供方式不同 <ul><li>函数由编程语言提供；</li><li>系统调用由操作系统提供。</li></ul></li></ul>',15)]))}const d=i(u,[["render",r]]),o=JSON.parse('{"path":"/blogs/xxbj/OS/2.html","title":"操作系统体系结构","lang":"en-US","frontmatter":{"title":"操作系统体系结构","date":"2022-03-20T00:00:00.000Z","tags":["操作系统"],"categories":["学习笔记"]},"headers":[{"level":2,"title":"操作系统服务","slug":"操作系统服务","link":"#操作系统服务","children":[]},{"level":2,"title":"操作系统运行模式","slug":"操作系统运行模式","link":"#操作系统运行模式","children":[{"level":3,"title":"区分应用程序和操作系统程序","slug":"区分应用程序和操作系统程序","link":"#区分应用程序和操作系统程序","children":[]}]},{"level":2,"title":"系统调用","slug":"系统调用","link":"#系统调用","children":[{"level":3,"title":"系统调用的类型","slug":"系统调用的类型","link":"#系统调用的类型","children":[]},{"level":3,"title":"与函数调用的区别","slug":"与函数调用的区别","link":"#与函数调用的区别","children":[]}]}],"git":{"createdTime":1748156404000,"updatedTime":1748156404000,"contributors":[{"name":"PPPerryPan","email":"perrypan0123@outlook.com","commits":1}]},"filePathRelative":"blogs/xxbj/OS/2.md"}');import.meta.webpackHot&&(import.meta.webpackHot.accept(),__VUE_HMR_RUNTIME__.updatePageData&&__VUE_HMR_RUNTIME__.updatePageData(o));export{d as comp,o as data};
