import{_ as i,c,a as e,b as r,d as t,e as o,r as u,o as n}from"./app-CUDFWA7u.js";const a={},s={href:"https://deerchao.cn/tutorials/regex/regex.htm",target:"_blank",rel:"noopener noreferrer"},p={href:"https://deerchao.cn/tools/wegester/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://deerchao.cn/tools/regester/",target:"_blank",rel:"noopener noreferrer"};function g(b,d){const l=u("ExternalLinkIcon");return n(),c("div",null,[d[6]||(d[6]=e("h2",{id:"备注",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#备注"},[e("span",null,"备注")])],-1)),e("p",null,[d[1]||(d[1]=t("参考教程：")),e("a",s,[d[0]||(d[0]=t("正则表达式30分钟入门教程 (deerchao.cn)")),o(l)])]),e("p",null,[d[3]||(d[3]=t("正则练习或测试：")),e("a",p,[d[2]||(d[2]=t("wegester, 在线正则表达式测试器(JavaScript) (deerchao.cn)")),o(l)])]),e("p",null,[d[5]||(d[5]=t(".NET 正则测试工具：")),e("a",h,[d[4]||(d[4]=t("Regester - 正则表达式测试工具 (deerchao.cn)")),o(l)])]),d[7]||(d[7]=r('<ul><li>Windows <strong>通配符(wildcard)</strong>，也就是 <code>*</code> 和 <code>?</code> 。如果你想查找某个目录下的所有的 Word 文档的话，你会搜索 <code>*.doc</code> 。在这里，<code>*</code> 会被解释成任意的字符串。</li><li>和通配符类似，正则表达式也是用来进行文本匹配的工具，但它能更精确地描述你的需求，同时也更复杂 <ul><li>如：<u>查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串</u>（010-12345678 或 0376-7654321）</li></ul></li><li>转义符：<code>\\</code></li></ul><h3 id="元字符" tabindex="-1"><a class="header-anchor" href="#元字符"><span>元字符</span></a></h3><ul><li><p>假设你在一篇英文小说里查找 <strong>hi</strong>，你可以使用正则表达式 <code>hi</code></p><ul><li>它可以精确匹配：由两个字符组成，前一个字符是 <strong>h</strong>，后一个是 <strong>i</strong><ul><li>通常，可选是否忽略大小写</li></ul></li></ul></li><li><p>但使用 <code>hi</code> 会同时匹配很多包含这两个连续字符，比如 him, history, high 等，也会被查找出来</p></li><li><p>如果要精确查找 <strong>hi</strong> 这个单词，应使用 <code>\\bhi\\b</code></p><ul><li><code>\\b</code> 在正则里可以叫做 “元字符，metacharacter”，<u>代表单词的开头或结尾，也就是单词的分界处</u>。</li><li>虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是 <code>\\b</code> 并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong></li></ul></li><li><p>如果要找的是 <u>hi 后面不远处跟着一个 Lucy</u>，你应该用 <code>\\bhi\\b.*\\bLucy\\b</code></p><ul><li>含义：先是一个单词 hi，然后是任意个任意字符(但不能是换行)，最后是 Lucy 这个单词</li><li><code>.</code> 是另一个元字符，匹配<u>除了换行符以外的任意字符</u>。</li><li><code>*</code> 同样是元字符，代表的不是字符，也不是位置，而是数量：它<u>指定 * 前边的内容可以连续重复使用任意次</u>，以使整个表达式得到匹配。</li><li><code>.*</code> 连在一起就意味着任意数量的不包含换行的字符</li></ul></li><li><p>同时使用多个元字符，就能构造更强的表达式</p><ul><li><code>0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d</code> <u>以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字</u><ul><li><code>\\d</code> 是个新的元字符，匹配一位数字 (0，或1，或2，或……)</li><li><code>-</code> 不是元字符，只匹配它本身。</li></ul></li></ul></li><li><p>更多例子</p><ul><li><p><code>\\ba\\w*\\b</code> <u>单词开始，以字母a开头单词，字母a，任意数量的数字或字母或下划线或汉字，单词结束</u></p></li><li><p><code>\\d+</code> <u>1个或更多连续的数字</u></p><ul><li><code>+</code> 是和 <code>*</code> 类似的元字符， <ul><li><code>*</code> 匹配 <u>重复任意次</u>(可能是0次)</li><li><code>+</code> 匹配 <u>重复1次或更多次</u></li></ul></li></ul></li><li><p><code>\\b\\w{6}\\b</code> 匹配</p></li></ul></li><li><p>元字符 <code>^</code> 和 <code>$</code> 都匹配一个位置，这和 <code>\\b</code> 有点类似。</p><ul><li><code>^</code> 匹配你要用来查找的字符串的开头，<code>$</code> 匹配结尾</li><li><code>\\d{5~12}$</code> <u>要求填写 5 ~ 12 位数字</u></li></ul></li></ul><h4 id="常用元字符" tabindex="-1"><a class="header-anchor" href="#常用元字符"><span>常用元字符：</span></a></h4><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\\s</td><td>匹配任意的空白符</td></tr><tr><td>\\d</td><td>匹配数字</td></tr><tr><td>\\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><h3 id="重复" tabindex="-1"><a class="header-anchor" href="#重复"><span>重复</span></a></h3><ul><li>像 <code>*</code>, <code>+</code> <code>{2}</code>. <code>{5,12}</code> 这种，就是关于重复的限定符</li><li>使用例 <ul><li><code>Windows\\d+</code> <u>Windows后面跟一个或多个数字</u></li><li><code>^\\w+</code> 一行的第一个单词或字符串的第一个单词</li></ul></li></ul><h4 id="常用限定符" tabindex="-1"><a class="header-anchor" href="#常用限定符"><span>常用限定符</span></a></h4><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h3 id="字符类" tabindex="-1"><a class="header-anchor" href="#字符类"><span>字符类</span></a></h3><ul><li><p>查找数字/字母/空格，有对应的元字符，，但如果没有预定义的字符集合，可在方括号列出使用</p><ul><li><code>[aeiou]</code> <u>任意一个英文原因字母</u></li><li><code>[.?!]</code> <u>标点 . / ? / !</u></li><li><code>[0-9]</code> <u>一位数字</u> ，作用与 <code>\\d</code> 一样</li><li><code>[a-z0-9A-Z]</code> 在只考虑英文的前提下也等同于 <code>/w</code></li></ul></li><li><p><code>\\(?0\\d{2}[) -]?\\d{8}</code> 匹配 <u>几种格式的电话号码</u></p><ul><li>(010)88886666 或 022-22334455 或 02912345678</li><li><code>\\(?0\\d{2}</code>：首先是一个转义字符 <code>(\\</code> 可出现 0 次 或 1 次 (?) ，然后是一个 <code>0</code>，后面跟着两个数字 <code>{2}</code>，</li><li><code>[) -]?</code>：然后是 <code>)</code> 或 <code></code> 或 <code>-</code> 中的一个 ，这三个可能出现，也可能不出现</li><li><code>\\d{8}</code>：8 个数字</li></ul></li></ul><h3 id="分支条件" tabindex="-1"><a class="header-anchor" href="#分支条件"><span>分支条件</span></a></h3><p>上面的表达式，也有一些问题，他能匹配到 010)12345678 或 (022-87654321 这样的 “不正确” 的格式，可使用 分支条件 解决，携程 满足任意一种规则都应该匹配，方法是用 <code>|</code> 把不同的规则分开。</p><ul><li><code>0\\d{2}-\\d{8}|0\\d{3}-\\d{7}</code> 匹配 <u>两种以连字符分隔的电话号码</u><ul><li><code> 0\\d{2}-\\d{8}</code> <u>3 位区号，8 位 本地号</u></li><li><code>0\\d{3}-\\d{7}</code> <u>4 位区号，7 位 本地号</u></li></ul></li><li><code>\\(0\\d{2}\\)[- ]?\\d{8}|0\\d{2}[- ]?\\d{8}</code><ul><li><code>\\(0\\d{2}\\)</code> | <code>0\\d{2}</code> <u>三位区号，其中区号可以用小括号括起来，也可以不用</u></li><li><code>[- ]?</code> <u>区号与本地号间可以用连字符或空格分开，也可以没有</u></li><li><code>\\d{8}</code> <u>八位数字</u></li></ul></li><li><code>\\d{5}-\\d{4}|\\d{5}</code> 匹配 <u>美国邮政编码</u><ul><li>美国邮编的规则是5位数字，或者用连字号间隔的9位数字</li><li><strong>使用分枝条件时，要注意各个条件的顺序</strong></li><li>如果你把它改成 <code>\\d{5}|\\d{5}-\\d{4}</code> 的话，就只会匹配 5 位的邮编(以及9位邮编的前 5 位)</li></ul></li></ul><h3 id="分组" tabindex="-1"><a class="header-anchor" href="#分组"><span>分组</span></a></h3><p>前面提到了如何重复单个字符（直接加限定符即可），但如果要重复多个字符，可以用小括号来指定 <strong>子表达式</strong>，又名 <strong>分组</strong> ，然后就可以指定这个子表达式的重复次数，同时，子表达式也有一些操作方法。</p><ul><li><p><code>(\\d{1,3}\\.){3}\\d{1,3}</code> <u>简单的 IP 地址匹配</u></p><ul><li><code>\\d{1,3}</code>：1~3 位数字</li><li><code>(\\d{1,3}\\.){3}</code>：<u>三位数字加上一个半角句号（这个整体就是这个分组）重复三次</u></li><li><code>\\d{1,3}</code>：<u>一个 1~3 位的数字</u></li></ul></li><li><p>上述表达式也将匹配 256.300.888.999 这类不存在的 IP，在正则中，只能用冗长的分组，选择，字符类来描述一个正确的IP地址：<code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code></p><ul><li><code>((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)</code>: 这一部分匹配IPv4地址的每个“点”之前的部分。它包含三个可能的组合： <ul><li><code>2[0-4]\\d</code>: 表示以2开头，后跟0到4之间的数字，范围是200-249。</li><li><code>25[0-5]</code>: 表示以25开头，后跟0到5之间的数字，范围是250-255。</li><li><code>[01]?\\d\\d?</code>: 表示一位或两位数字，可以以0或1开头。</li></ul></li><li><code>{3}</code>: 表示前述的整个模式（带点）需要重复匹配三次，确保匹配IP地址的前三个部分。</li><li><code>(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)</code>: 这一部分匹配IP地址的最后一部分，规则与第一部分相似。</li></ul></li></ul><h3 id="反义" tabindex="-1"><a class="header-anchor" href="#反义"><span>反义</span></a></h3><p>用于查找不属于某个能简单定义的字符类的字符</p><ul><li><code>\\S+</code> <u>不包括空白符的字符串</u></li><li><code>&lt;a[^&gt;]+&gt;</code> <u>用尖括号括起来的以 a 开头的字符串</u></li></ul><h4 id="常用的反义代码" tabindex="-1"><a class="header-anchor" href="#常用的反义代码"><span>常用的反义代码</span></a></h4><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>\\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><h3 id="后向引用" tabindex="-1"><a class="header-anchor" href="#后向引用"><span>后向引用</span></a></h3><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。</p><p>默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><blockquote><p>详细版：</p><ul><li>分组0对应整个正则表达式</li><li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li><li>你可以使用 <code>(?:exp)</code> 这样的语法来剥夺一个分组对组号分配的参与权．</li></ul></blockquote><ul><li><strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本 <ul><li><code>\\1</code> 代表 <u>分组 1 匹配的文本</u><ul><li><code>\\b(\\w+)\\b\\s+\\1\\b</code> <u>匹配重复的单词</u>，如：go go 或 hi hi <ul><li><code>\\b(\\w+)\\b</code> 这个表达式首先是<u>一个单词</u>，也就是<u>单词开始处和结束处之间的多于一个的字母或数字</u></li><li><code>\\s+</code> 这个单词会被捕获到编号为1的分组中，然后是<u>1个或几个空白符</u></li><li><code>\\1</code> 最后是<u>分组1中捕获的内容（也就是前面匹配的那个单词）</u></li></ul></li></ul></li></ul></li></ul><blockquote><p>GPT 版解释：</p><ul><li><code>\\b</code>: 单词的边界，确保匹配的是整个单词而不是单词的一部分。</li><li><code>(\\w+)</code>: 匹配并捕获一个或多个单词字符（字母、数字、下划线）。这是第一个捕获组。</li><li><code>\\s+</code>: 匹配一个或多个空白字符。</li><li><code>\\1</code>: 引用第一个捕获组，确保与前面捕获的内容相同。</li><li><code>\\b</code>: 单词的边界，确保匹配的是整个单词而不是单词的一部分。</li></ul><p>这个正则表达式的目的是查找重复的单词，例如 &quot;word word&quot; 或 &quot;test test&quot;。这里使用了捕获组和引用，以确保匹配的是两次出现相同的单词。</p></blockquote><p>也可以自己指定子表达式的<strong>组名</strong>：<code>(?&lt;Word&gt;w+)</code> 或把尖括号换成 <code>&#39;</code>：<code>(?&#39;Word&#39;\\w+))</code></p><h4 id="使用小括号时的特殊语法" tabindex="-1"><a class="header-anchor" href="#使用小括号时的特殊语法"><span>使用小括号时的特殊语法</span></a></h4><blockquote><p><code>(?:exp)</code> 不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。</p></blockquote><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><strong>捕获</strong></td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td><strong>捕获</strong></td><td>(?&lt;name&gt;exp)</td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?&#39;name&#39;exp)</td></tr><tr><td><strong>捕获</strong></td><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td><strong>零宽断言</strong></td><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td><strong>零宽断言</strong></td><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td></tr><tr><td><strong>零宽断言</strong></td><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td></tr><tr><td><strong>零宽断言</strong></td><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr><tr><td><strong>注释</strong></td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><h2 id="零宽断言" tabindex="-1"><a class="header-anchor" href="#零宽断言"><span>零宽断言</span></a></h2><p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，它们像 <code>\\b</code>、<code>^</code>、<code>$</code> 那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此他们也能称为 “零宽断言”</p><ul><li><p><code>(?=exp)</code> 也叫<strong>零宽度正预测先行断言</strong>，它 <u>断言自身出现的位置的后面能匹配表达式 exp</u> 。</p><ul><li>比如 <code>\\b\\w+(?=ing\\b)</code>，匹配 <u>以ing结尾的单词的前面部分(除了ing以外的部分)</u>， <ul><li>查找 <em>I&#39;m singing while you&#39;re dancing.</em> 时，它会匹配 <u>sing</u> 和 <u>danc</u> 。</li></ul></li></ul></li><li><p><code>(?&lt;=exp)</code> 也叫<strong>零宽度正回顾后发断言</strong>，它 <u>断言自身出现的位置的前面能匹配表达式 exp</u>。</p><ul><li>比如 <code>(?&lt;=\\bre)\\w+\\b</code> 会匹配 <u>以re开头的单词的后半部分(除了re以外的部分)</u>， <ul><li>查找 <em>reading a book</em> 时，它匹配 <u>ading</u> 。</li></ul></li></ul></li><li><p>如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，可以这样查找需要在前面和里面添加逗号的部分：</p><ul><li><code>((?&lt;=\\d)\\d{3})+\\b</code> ，用它对 <em>1234567890</em> 进行查找时结果是 <u>234567890</u>。</li></ul></li><li><p>同时使用两种断言的举例</p><ul><li><code>(?&lt;=\\s)\\d+(?=\\s)</code> 匹配 <u>以空白符间隔的数字(再次强调，不包括这些空白符)</u></li></ul></li></ul><h2 id="负向零宽断言" tabindex="-1"><a class="header-anchor" href="#负向零宽断言"><span>负向零宽断言</span></a></h2><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？</p><ul><li>例如，如果我们想查找这样的单词：它里面出现了字母 q，但是 q 后面跟的不是字母 u。 <ul><li><code>\\b\\w*q[^u]\\w*\\b</code> 匹配 <u>包含<strong>后面不是字母u的字母q</strong>的单词</u>，但是这个正则会有 Bug，如果q出现在单词的结尾的话，像 <strong>Iraq</strong>, <strong>Benq</strong>，这个表达式就会出错，</li></ul></li></ul>',38))])}const m=i(a,[["render",g]]),f=JSON.parse('{"path":"/blogs/tech/programming/01_re.html","title":"正则表达式-入门","lang":"en-US","frontmatter":{"title":"正则表达式-入门","date":"2023-11-11T00:00:00.000Z","tags":null,"categories":["tech"]},"headers":[{"level":2,"title":"备注","slug":"备注","link":"#备注","children":[{"level":3,"title":"元字符","slug":"元字符","link":"#元字符","children":[]},{"level":3,"title":"重复","slug":"重复","link":"#重复","children":[]},{"level":3,"title":"字符类","slug":"字符类","link":"#字符类","children":[]},{"level":3,"title":"分支条件","slug":"分支条件","link":"#分支条件","children":[]},{"level":3,"title":"分组","slug":"分组","link":"#分组","children":[]},{"level":3,"title":"反义","slug":"反义","link":"#反义","children":[]},{"level":3,"title":"后向引用","slug":"后向引用","link":"#后向引用","children":[]}]},{"level":2,"title":"零宽断言","slug":"零宽断言","link":"#零宽断言","children":[]},{"level":2,"title":"负向零宽断言","slug":"负向零宽断言","link":"#负向零宽断言","children":[]}],"git":{"createdTime":1766928673000,"updatedTime":1766928673000,"contributors":[{"name":"PPPerryPan","email":"perrypan0123@outlook.com","commits":1}]},"filePathRelative":"blogs/tech/programming/01_re.md"}');export{m as comp,f as data};
