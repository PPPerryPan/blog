---
title: 正则表达式-入门
date: 2023-11-11
tags:
categories:
  - tech
---

## 备注

参考教程：[正则表达式30分钟入门教程 (deerchao.cn)](https://deerchao.cn/tutorials/regex/regex.htm)

正则练习或测试：[wegester, 在线正则表达式测试器(JavaScript) (deerchao.cn)](https://deerchao.cn/tools/wegester/)

.NET 正则测试工具：[Regester - 正则表达式测试工具 (deerchao.cn)](https://deerchao.cn/tools/regester/)

- Windows **通配符(wildcard)**，也就是 `*` 和 `?` 。如果你想查找某个目录下的所有的 Word 文档的话，你会搜索 `*.doc` 。在这里，`*` 会被解释成任意的字符串。
- 和通配符类似，正则表达式也是用来进行文本匹配的工具，但它能更精确地描述你的需求，同时也更复杂
  - 如：<u>查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串</u>（010-12345678 或 0376-7654321）
- 转义符：`\`

### 元字符

- 假设你在一篇英文小说里查找 **hi**，你可以使用正则表达式 `hi`
  - 它可以精确匹配：由两个字符组成，前一个字符是 **h**，后一个是 **i**
    - 通常，可选是否忽略大小写
- 但使用 `hi` 会同时匹配很多包含这两个连续字符，比如 him, history, high 等，也会被查找出来
- 如果要精确查找 **hi** 这个单词，应使用 `\bhi\b`
  -  `\b` 在正则里可以叫做 “元字符，metacharacter”，<u>代表单词的开头或结尾，也就是单词的分界处</u>。
  - 虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是 `\b` 并不匹配这些单词分隔字符中的任何一个，它**只匹配一个位置**
- 如果要找的是 <u>hi 后面不远处跟着一个 Lucy</u>，你应该用 `\bhi\b.*\bLucy\b`
  - 含义：先是一个单词 hi，然后是任意个任意字符(但不能是换行)，最后是 Lucy 这个单词
  - `.` 是另一个元字符，匹配<u>除了换行符以外的任意字符</u>。
  - `*` 同样是元字符，代表的不是字符，也不是位置，而是数量：它<u>指定 \* 前边的内容可以连续重复使用任意次</u>，以使整个表达式得到匹配。
  - `.*` 连在一起就意味着任意数量的不包含换行的字符
  
- 同时使用多个元字符，就能构造更强的表达式
  - `0\d\d-\d\d\d\d\d\d\d\d` <u>以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字</u>
    - `\d` 是个新的元字符，匹配一位数字 (0，或1，或2，或……)
    - `-` 不是元字符，只匹配它本身。

- 更多例子
  - `\ba\w*\b` <u>单词开始，以字母a开头单词，字母a，任意数量的数字或字母或下划线或汉字，单词结束</u>
  - `\d+` <u>1个或更多连续的数字</u> 
    - `+` 是和 `*` 类似的元字符，
      - `*` 匹配 <u>重复任意次</u>(可能是0次)
      - `+` 匹配 <u>重复1次或更多次</u>

  - `\b\w{6}\b` 匹配

- 元字符 `^` 和 `$` 都匹配一个位置，这和 `\b` 有点类似。
  - `^` 匹配你要用来查找的字符串的开头，`$` 匹配结尾
  - `\d{5~12}$` <u>要求填写 5 ~ 12 位数字</u>


#### 常用元字符：

| 代码 | 说明                         |
| ---- | ---------------------------- |
| .    | 匹配除换行符以外的任意字符   |
| \w   | 匹配字母或数字或下划线或汉字 |
| \s   | 匹配任意的空白符             |
| \d   | 匹配数字                     |
| \b   | 匹配单词的开始或结束         |
| ^    | 匹配字符串的开始             |
| $    | 匹配字符串的结束             |

### 重复

- 像 `*`, `+` `{2}`. `{5,12}` 这种，就是关于重复的限定符
- 使用例
  - `Windows\d+` <u>Windows后面跟一个或多个数字</u>
  - `^\w+` 一行的第一个单词或字符串的第一个单词

#### 常用限定符

| 代码/语法 | 说明             |
| --------- | ---------------- |
| *         | 重复零次或更多次 |
| +         | 重复一次或更多次 |
| ?         | 重复零次或一次   |
| {n}       | 重复n次          |
| {n,}      | 重复n次或更多次  |
| {n,m}     | 重复n到m次       |



### 字符类

- 查找数字/字母/空格，有对应的元字符，，但如果没有预定义的字符集合，可在方括号列出使用
  - `[aeiou]` <u>任意一个英文原因字母</u>
  - `[.?!]` <u>标点 . / ? / !</u>
  - `[0-9]` <u>一位数字</u> ，作用与 `\d` 一样 
  - `[a-z0-9A-Z]` 在只考虑英文的前提下也等同于 `/w`

- `\(?0\d{2}[) -]?\d{8}` 匹配 <u>几种格式的电话号码</u>
  - (010)88886666 或 022-22334455 或 02912345678
  - `\(?0\d{2}`：首先是一个转义字符 `(\` 可出现 0 次 或 1 次 (?) ，然后是一个 `0`，后面跟着两个数字 `{2}`，
  - `[) -]?`：然后是 `)` 或 ` ` 或 `-` 中的一个 ，这三个可能出现，也可能不出现
  - `\d{8}`：8 个数字 



### 分支条件

上面的表达式，也有一些问题，他能匹配到 010)12345678 或 (022-87654321 这样的 “不正确” 的格式，可使用 分支条件 解决，携程 满足任意一种规则都应该匹配，方法是用 `|` 把不同的规则分开。



- `0\d{2}-\d{8}|0\d{3}-\d{7}` 匹配 <u>两种以连字符分隔的电话号码</u>
  - ` 0\d{2}-\d{8}` <u>3 位区号，8 位 本地号</u>
  - `0\d{3}-\d{7}` <u>4 位区号，7 位 本地号</u>
- `\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}` 
  - `\(0\d{2}\)` | `0\d{2}` <u>三位区号，其中区号可以用小括号括起来，也可以不用</u>
  - `[- ]?` <u>区号与本地号间可以用连字符或空格分开，也可以没有</u>
  - `\d{8}` <u>八位数字</u>
- `\d{5}-\d{4}|\d{5}` 匹配 <u>美国邮政编码</u>
  - 美国邮编的规则是5位数字，或者用连字号间隔的9位数字
  - **使用分枝条件时，要注意各个条件的顺序**
  - 如果你把它改成 `\d{5}|\d{5}-\d{4}` 的话，就只会匹配 5 位的邮编(以及9位邮编的前 5 位)



### 分组

前面提到了如何重复单个字符（直接加限定符即可），但如果要重复多个字符，可以用小括号来指定 **子表达式**，又名 **分组** ，然后就可以指定这个子表达式的重复次数，同时，子表达式也有一些操作方法。

- `(\d{1,3}\.){3}\d{1,3}` <u>简单的 IP 地址匹配</u> 
  - `\d{1,3}`：1~3 位数字
  - `(\d{1,3}\.){3}`：<u>三位数字加上一个半角句号（这个整体就是这个分组）重复三次</u>
  - `\d{1,3}`：<u>一个 1~3 位的数字</u>

- 上述表达式也将匹配 256.300.888.999 这类不存在的 IP，在正则中，只能用冗长的分组，选择，字符类来描述一个正确的IP地址：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`
  - `((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)`: 这一部分匹配IPv4地址的每个“点”之前的部分。它包含三个可能的组合：
    - `2[0-4]\d`: 表示以2开头，后跟0到4之间的数字，范围是200-249。
    - `25[0-5]`: 表示以25开头，后跟0到5之间的数字，范围是250-255。
    - `[01]?\d\d?`: 表示一位或两位数字，可以以0或1开头。
  - `{3}`: 表示前述的整个模式（带点）需要重复匹配三次，确保匹配IP地址的前三个部分。
  - `(2[0-4]\d|25[0-5]|[01]?\d\d?)`: 这一部分匹配IP地址的最后一部分，规则与第一部分相似。

### 反义

用于查找不属于某个能简单定义的字符类的字符

- `\S+` <u>不包括空白符的字符串</u>
- `<a[^>]+>` <u>用尖括号括起来的以 a 开头的字符串</u>

#### 常用的反义代码

| 代码/语法 | 说明                                       |
| --------- | ------------------------------------------ |
| \W        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S        | 匹配任意不是空白符的字符                   |
| \D        | 匹配任意非数字的字符                       |
| \B        | 匹配不是单词开头或结束的位置               |
| [^x]      | 匹配除了x以外的任意字符                    |
| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |



### 后向引用

使用小括号指定一个子表达式后，**匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。

默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

> 详细版：
>
> - 分组0对应整个正则表达式
> - 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
> - 你可以使用 `(?:exp)` 这样的语法来剥夺一个分组对组号分配的参与权．

- **后向引用**用于重复搜索前面某个分组匹配的文本
  - `\1` 代表 <u>分组 1 匹配的文本</u>
    - `\b(\w+)\b\s+\1\b` <u>匹配重复的单词</u>，如：go go 或 hi hi
      - `\b(\w+)\b` 这个表达式首先是<u>一个单词</u>，也就是<u>单词开始处和结束处之间的多于一个的字母或数字</u> 
      - `\s+` 这个单词会被捕获到编号为1的分组中，然后是<u>1个或几个空白符</u>
      - `\1` 最后是<u>分组1中捕获的内容（也就是前面匹配的那个单词）</u>

> GPT 版解释：
>
> - `\b`: 单词的边界，确保匹配的是整个单词而不是单词的一部分。
> - `(\w+)`: 匹配并捕获一个或多个单词字符（字母、数字、下划线）。这是第一个捕获组。
> - `\s+`: 匹配一个或多个空白字符。
> - `\1`: 引用第一个捕获组，确保与前面捕获的内容相同。
> - `\b`: 单词的边界，确保匹配的是整个单词而不是单词的一部分。
>
> 这个正则表达式的目的是查找重复的单词，例如 "word word" 或 "test test"。这里使用了捕获组和引用，以确保匹配的是两次出现相同的单词。



也可以自己指定子表达式的**组名**：`(?<Word>w+)` 或把尖括号换成 `'`：`(?'Word'\w+))`

#### 使用小括号时的特殊语法

> `(?:exp)` 不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。

| 分类         | 代码/语法     | 说明                                                         |
| ------------ | ------------- | ------------------------------------------------------------ |
| **捕获**     | (exp)         | 匹配exp,并捕获文本到自动命名的组里                           |
| **捕获**     | (?\<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |
| **捕获**     | (?:exp)       | 匹配exp,不捕获匹配的文本，也不给此分组分配组号               |
| **零宽断言** | (?=exp)       | 匹配exp前面的位置                                            |
| **零宽断言** | (?<=exp)      | 匹配exp后面的位置                                            |
| **零宽断言** | (?!exp)       | 匹配后面跟的不是exp的位置                                    |
| **零宽断言** | (?<!exp)      | 匹配前面不是exp的位置                                        |
| **注释**     | (?#comment)   | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |



## 零宽断言

用于查找在某些内容(但并不包括这些内容)之前或之后的东西，它们像 `\b`、`^`、`$` 那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此他们也能称为 “零宽断言”

- `(?=exp)` 也叫**零宽度正预测先行断言**，它 <u>断言自身出现的位置的后面能匹配表达式 exp</u> 。
  - 比如 `\b\w+(?=ing\b)`，匹配 <u>以ing结尾的单词的前面部分(除了ing以外的部分)</u>，
    - 查找 *I'm singing while you're dancing.* 时，它会匹配 <u>sing</u> 和 <u>danc</u> 。

- `(?<=exp)` 也叫**零宽度正回顾后发断言**，它 <u>断言自身出现的位置的前面能匹配表达式 exp</u>。
  - 比如 `(?<=\bre)\w+\b` 会匹配 <u>以re开头的单词的后半部分(除了re以外的部分)</u>，
    - 查找 *reading a book* 时，它匹配 <u>ading</u> 。

- 如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，可以这样查找需要在前面和里面添加逗号的部分：
  - `((?<=\d)\d{3})+\b` ，用它对 *1234567890* 进行查找时结果是 <u>234567890</u>。
- 同时使用两种断言的举例
  - `(?<=\s)\d+(?=\s)` 匹配 <u>以空白符间隔的数字(再次强调，不包括这些空白符)</u>



## 负向零宽断言

前面我们提到过怎么查找**不是某个字符或不在某个字符类里**的字符的方法(反义)。但是如果我们只是想要**确保某个字符没有出现，但并不想去匹配它**时怎么办？

- 例如，如果我们想查找这样的单词：它里面出现了字母 q，但是 q 后面跟的不是字母 u。
  - `\b\w*q[^u]\w*\b` 匹配 <u>包含**后面不是字母u的字母q**的单词</u>，但是这个正则会有 Bug，如果q出现在单词的结尾的话，像 **Iraq**, **Benq**，这个表达式就会出错，













 